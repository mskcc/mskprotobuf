/*
Genome Nexus API

This page shows how to use HTTP requests to access the Genome Nexus API. There are more high level clients available in Python, R, JavaScript, TypeScript and various other languages as well as a command line client to annotate MAF and VCF. See https://docs.genomenexus.org/api.  Aside from programmatic clients there are web based tools to annotate variants, see https://docs.genomenexus.org/tools.   We currently only provide long-term support for the '/annotation' endpoint. The other endpoints might change.

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package genome_nexus_internal_api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// EnsemblControllerApiService EnsemblControllerApi service
type EnsemblControllerApiService service

type ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	entrezGeneId string
}

func (r ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest) Execute() (*EnsemblGene, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblGeneIdByEntrezGeneIdGETExecute(r)
}

/*
FetchCanonicalEnsemblGeneIdByEntrezGeneIdGET Retrieves Ensembl canonical gene id by Entrez Gene Id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param entrezGeneId An Entrez Gene Id. For example 23140
 @return ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByEntrezGeneIdGET(ctx context.Context, entrezGeneId string) ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest {
	return ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest{
		ApiService: a,
		ctx: ctx,
		entrezGeneId: entrezGeneId,
	}
}

// Execute executes the request
//  @return EnsemblGene
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByEntrezGeneIdGETExecute(r ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdGETRequest) (*EnsemblGene, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnsemblGene
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblGeneIdByEntrezGeneIdGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-gene/entrez/{entrezGeneId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entrezGeneId"+"}", url.PathEscape(parameterToString(r.entrezGeneId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	entrezGeneIds *[]string
}

// List of Entrez Gene Ids. For example [\&quot;23140\&quot;,\&quot;26009\&quot;,\&quot;100131879\&quot;]
func (r ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest) EntrezGeneIds(entrezGeneIds []string) ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest {
	r.entrezGeneIds = &entrezGeneIds
	return r
}

func (r ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest) Execute() ([]EnsemblGene, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTExecute(r)
}

/*
FetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOST Retrieves canonical Ensembl Gene ID by Entrez Gene Ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOST(ctx context.Context) ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest {
	return ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnsemblGene
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTExecute(r ApiFetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOSTRequest) ([]EnsemblGene, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnsemblGene
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblGeneIdByEntrezGeneIdsPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-gene/entrez"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entrezGeneIds == nil {
		return localVarReturnValue, nil, reportError("entrezGeneIds is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.entrezGeneIds
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	hugoSymbol string
}

func (r ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest) Execute() (*EnsemblGene, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblGeneIdByHugoSymbolGETExecute(r)
}

/*
FetchCanonicalEnsemblGeneIdByHugoSymbolGET Retrieves Ensembl canonical gene id by Hugo Symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hugoSymbol A Hugo Symbol. For example TP53
 @return ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByHugoSymbolGET(ctx context.Context, hugoSymbol string) ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest {
	return ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest{
		ApiService: a,
		ctx: ctx,
		hugoSymbol: hugoSymbol,
	}
}

// Execute executes the request
//  @return EnsemblGene
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByHugoSymbolGETExecute(r ApiFetchCanonicalEnsemblGeneIdByHugoSymbolGETRequest) (*EnsemblGene, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnsemblGene
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblGeneIdByHugoSymbolGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-gene/hgnc/{hugoSymbol}"
	localVarPath = strings.Replace(localVarPath, "{"+"hugoSymbol"+"}", url.PathEscape(parameterToString(r.hugoSymbol, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	hugoSymbols *[]string
}

// List of Hugo Symbols. For example [\&quot;TP53\&quot;,\&quot;PIK3CA\&quot;,\&quot;BRCA1\&quot;]
func (r ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest) HugoSymbols(hugoSymbols []string) ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest {
	r.hugoSymbols = &hugoSymbols
	return r
}

func (r ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest) Execute() ([]EnsemblGene, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTExecute(r)
}

/*
FetchCanonicalEnsemblGeneIdByHugoSymbolsPOST Retrieves canonical Ensembl Gene ID by Hugo Symbols

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByHugoSymbolsPOST(ctx context.Context) ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest {
	return ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnsemblGene
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTExecute(r ApiFetchCanonicalEnsemblGeneIdByHugoSymbolsPOSTRequest) ([]EnsemblGene, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnsemblGene
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblGeneIdByHugoSymbolsPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-gene/hgnc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hugoSymbols == nil {
		return localVarReturnValue, nil, reportError("hugoSymbols is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hugoSymbols
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	hugoSymbol string
	isoformOverrideSource *string
}

// Isoform override source. For example uniprot
func (r ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest) IsoformOverrideSource(isoformOverrideSource string) ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest {
	r.isoformOverrideSource = &isoformOverrideSource
	return r
}

func (r ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest) Execute() (*EnsemblTranscript, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblTranscriptByHugoSymbolGETExecute(r)
}

/*
FetchCanonicalEnsemblTranscriptByHugoSymbolGET Retrieves Ensembl canonical transcript by Hugo Symbol

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hugoSymbol A Hugo Symbol. For example TP53
 @return ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblTranscriptByHugoSymbolGET(ctx context.Context, hugoSymbol string) ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest {
	return ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest{
		ApiService: a,
		ctx: ctx,
		hugoSymbol: hugoSymbol,
	}
}

// Execute executes the request
//  @return EnsemblTranscript
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblTranscriptByHugoSymbolGETExecute(r ApiFetchCanonicalEnsemblTranscriptByHugoSymbolGETRequest) (*EnsemblTranscript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnsemblTranscript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblTranscriptByHugoSymbolGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-transcript/hgnc/{hugoSymbol}"
	localVarPath = strings.Replace(localVarPath, "{"+"hugoSymbol"+"}", url.PathEscape(parameterToString(r.hugoSymbol, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.isoformOverrideSource != nil {
		localVarQueryParams.Add("isoformOverrideSource", parameterToString(*r.isoformOverrideSource, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	hugoSymbols *[]string
	isoformOverrideSource *string
}

// List of Hugo Symbols. For example [\&quot;TP53\&quot;,\&quot;PIK3CA\&quot;,\&quot;BRCA1\&quot;]
func (r ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest) HugoSymbols(hugoSymbols []string) ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest {
	r.hugoSymbols = &hugoSymbols
	return r
}

// Isoform override source. For example uniprot
func (r ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest) IsoformOverrideSource(isoformOverrideSource string) ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest {
	r.isoformOverrideSource = &isoformOverrideSource
	return r
}

func (r ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest) Execute() ([]EnsemblTranscript, *http.Response, error) {
	return r.ApiService.FetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTExecute(r)
}

/*
FetchCanonicalEnsemblTranscriptsByHugoSymbolsPOST Retrieves Ensembl canonical transcripts by Hugo Symbols

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest
*/
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblTranscriptsByHugoSymbolsPOST(ctx context.Context) ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest {
	return ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnsemblTranscript
func (a *EnsemblControllerApiService) FetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTExecute(r ApiFetchCanonicalEnsemblTranscriptsByHugoSymbolsPOSTRequest) ([]EnsemblTranscript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnsemblTranscript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchCanonicalEnsemblTranscriptsByHugoSymbolsPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/canonical-transcript/hgnc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.hugoSymbols == nil {
		return localVarReturnValue, nil, reportError("hugoSymbols is required and must be specified")
	}

	if r.isoformOverrideSource != nil {
		localVarQueryParams.Add("isoformOverrideSource", parameterToString(*r.isoformOverrideSource, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hugoSymbols
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchEnsemblTranscriptByTranscriptIdGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	transcriptId string
}

func (r ApiFetchEnsemblTranscriptByTranscriptIdGETRequest) Execute() (*EnsemblTranscript, *http.Response, error) {
	return r.ApiService.FetchEnsemblTranscriptByTranscriptIdGETExecute(r)
}

/*
FetchEnsemblTranscriptByTranscriptIdGET Retrieves the transcript by an Ensembl transcript ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transcriptId An Ensembl transcript ID. For example ENST00000361390
 @return ApiFetchEnsemblTranscriptByTranscriptIdGETRequest
*/
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptByTranscriptIdGET(ctx context.Context, transcriptId string) ApiFetchEnsemblTranscriptByTranscriptIdGETRequest {
	return ApiFetchEnsemblTranscriptByTranscriptIdGETRequest{
		ApiService: a,
		ctx: ctx,
		transcriptId: transcriptId,
	}
}

// Execute executes the request
//  @return EnsemblTranscript
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptByTranscriptIdGETExecute(r ApiFetchEnsemblTranscriptByTranscriptIdGETRequest) (*EnsemblTranscript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EnsemblTranscript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchEnsemblTranscriptByTranscriptIdGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/transcript/{transcriptId}"
	localVarPath = strings.Replace(localVarPath, "{"+"transcriptId"+"}", url.PathEscape(parameterToString(r.transcriptId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	ensemblFilter *EnsemblFilter
}

// List of Ensembl transcript IDs. For example [\&quot;ENST00000361390\&quot;, \&quot;ENST00000361453\&quot;, \&quot;ENST00000361624\&quot;]&lt;br&gt;OR&lt;br&gt;List of Hugo Symbols. For example [\&quot;TP53\&quot;, \&quot;PIK3CA\&quot;, \&quot;BRCA1\&quot;]&lt;br&gt;OR&lt;br&gt;List of Ensembl protein IDs. For example [\&quot;ENSP00000439985\&quot;, \&quot;ENSP00000478460\&quot;, \&quot;ENSP00000346196\&quot;]&lt;br&gt;OR&lt;br&gt;List of Ensembl gene IDs. For example [\&quot;ENSG00000136999\&quot;, \&quot;ENSG00000272398\&quot;, \&quot;ENSG00000198695\&quot;]
func (r ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest) EnsemblFilter(ensemblFilter EnsemblFilter) ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest {
	r.ensemblFilter = &ensemblFilter
	return r
}

func (r ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest) Execute() ([]EnsemblTranscript, *http.Response, error) {
	return r.ApiService.FetchEnsemblTranscriptsByEnsemblFilterPOSTExecute(r)
}

/*
FetchEnsemblTranscriptsByEnsemblFilterPOST Retrieves Ensembl Transcripts by Ensembl transcript IDs, hugo Symbols, protein IDs, or gene IDs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest
*/
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptsByEnsemblFilterPOST(ctx context.Context) ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest {
	return ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnsemblTranscript
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptsByEnsemblFilterPOSTExecute(r ApiFetchEnsemblTranscriptsByEnsemblFilterPOSTRequest) ([]EnsemblTranscript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnsemblTranscript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchEnsemblTranscriptsByEnsemblFilterPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/transcript"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ensemblFilter == nil {
		return localVarReturnValue, nil, reportError("ensemblFilter is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ensemblFilter
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchEnsemblTranscriptsGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	geneId *string
	proteinId *string
	hugoSymbol *string
}

// An Ensembl gene ID. For example ENSG00000136999
func (r ApiFetchEnsemblTranscriptsGETRequest) GeneId(geneId string) ApiFetchEnsemblTranscriptsGETRequest {
	r.geneId = &geneId
	return r
}

// An Ensembl protein ID. For example ENSP00000439985
func (r ApiFetchEnsemblTranscriptsGETRequest) ProteinId(proteinId string) ApiFetchEnsemblTranscriptsGETRequest {
	r.proteinId = &proteinId
	return r
}

// A Hugo Symbol For example ARF5
func (r ApiFetchEnsemblTranscriptsGETRequest) HugoSymbol(hugoSymbol string) ApiFetchEnsemblTranscriptsGETRequest {
	r.hugoSymbol = &hugoSymbol
	return r
}

func (r ApiFetchEnsemblTranscriptsGETRequest) Execute() ([]EnsemblTranscript, *http.Response, error) {
	return r.ApiService.FetchEnsemblTranscriptsGETExecute(r)
}

/*
FetchEnsemblTranscriptsGET Retrieves Ensembl Transcripts by protein ID, and gene ID. Retrieves all transcripts in case no query parameter provided

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchEnsemblTranscriptsGETRequest
*/
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptsGET(ctx context.Context) ApiFetchEnsemblTranscriptsGETRequest {
	return ApiFetchEnsemblTranscriptsGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []EnsemblTranscript
func (a *EnsemblControllerApiService) FetchEnsemblTranscriptsGETExecute(r ApiFetchEnsemblTranscriptsGETRequest) ([]EnsemblTranscript, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnsemblTranscript
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchEnsemblTranscriptsGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/transcript"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.geneId != nil {
		localVarQueryParams.Add("geneId", parameterToString(*r.geneId, ""))
	}
	if r.proteinId != nil {
		localVarQueryParams.Add("proteinId", parameterToString(*r.proteinId, ""))
	}
	if r.hugoSymbol != nil {
		localVarQueryParams.Add("hugoSymbol", parameterToString(*r.hugoSymbol, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFetchGeneXrefsGETRequest struct {
	ctx context.Context
	ApiService *EnsemblControllerApiService
	accession *string
}

// Ensembl gene accession. For example ENSG00000169083
func (r ApiFetchGeneXrefsGETRequest) Accession(accession string) ApiFetchGeneXrefsGETRequest {
	r.accession = &accession
	return r
}

func (r ApiFetchGeneXrefsGETRequest) Execute() ([]GeneXref, *http.Response, error) {
	return r.ApiService.FetchGeneXrefsGETExecute(r)
}

/*
FetchGeneXrefsGET Perform lookups of Ensembl identifiers and retrieve their external references in other databases

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFetchGeneXrefsGETRequest
*/
func (a *EnsemblControllerApiService) FetchGeneXrefsGET(ctx context.Context) ApiFetchGeneXrefsGETRequest {
	return ApiFetchGeneXrefsGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GeneXref
func (a *EnsemblControllerApiService) FetchGeneXrefsGETExecute(r ApiFetchGeneXrefsGETRequest) ([]GeneXref, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GeneXref
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnsemblControllerApiService.FetchGeneXrefsGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ensembl/xrefs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accession == nil {
		return localVarReturnValue, nil, reportError("accession is required and must be specified")
	}

	localVarQueryParams.Add("accession", parameterToString(*r.accession, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
